# [Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html)

## Property Modifiers

针对属性可以设置：
- 类型
- 是否可选
- 是否只读

```ts
interface SomeType {
  type: string
  optional?: boolean
  readonly readonly: boolean
}
```


### Index Signatures

索引签名：应用于不知道对象所有属性名的场景

```ts
interface StringArray {
  [index: number]: string;
}
```

> 索引签名里的 index 可以使用任意合法变量名，比如 `[key: number]: string`

只读的索引签名可以防止对其索引进行赋值。换句话说，当一个对象的索引签名是只读时，不能通过索引的方式修改这个对象的属性值。

```ts
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myArray: ReadonlyStringArray = getReadOnlyStringArray();
myArray[2] = "Mallory"; // 报错
```

## Excess Property Checks

多余属性检查， 是一种机制，用来确保 __对象字面量__ 不会传递超出预期的属性。

ts 的观点是，如果赋值或传参使用的是对象字面量，且对象中出现了类型上不存在的属性，那么这很有可能是一个bug。

绕过此检查的方法：
- 使用 as 断言
- 把字面量先赋给变量 然后再使用
- 加个 索引签名 （字面量必须有至少一个类型上的普通可选属性）


## Extending Types
 interface 中可以使用 extends 来扩展类型，且支持从多个类型扩展。

```ts
interface ColorfulCircle extends Colorful, Circle {}
```

## Intersection Types
交叉类型：组合现有对象类型（object types）

```ts
type ColorfulCircle = Colorful & Circle;
```

## Interfaces vs. Intersections

关键区别在于如何处理冲突属性。
- extends：冲突属性的类型必须兼容，否则报错
- intersection：合并冲突属性的类型，可能会导致意外结果（比如合并后是 never）

## Generic Object Types
泛型对象类型


